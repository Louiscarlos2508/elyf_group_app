import '../entities/audit_record.dart';
import '../repositories/audit_trail_repository.dart';

class AuditTrailService {
  final AuditTrailRepository _repository;

  AuditTrailService(this._repository);

  /// Logs a generic action.
  Future<String> logAction({
    required String enterpriseId,
    required String userId,
    required String module,
    required String action,
    required String entityId,
    required String entityType,
    Map<String, dynamic>? metadata,
  }) async {
    final record = AuditRecord(
      id: '', // Will be generated by repository
      enterpriseId: enterpriseId,
      userId: userId,
      module: module,
      action: action,
      entityId: entityId,
      entityType: entityType,
      metadata: metadata,
      timestamp: DateTime.now(),
    );

    return await _repository.log(record);
  }

  /// Convenience method for logging transactions.
  Future<String> logTransaction({
    required String enterpriseId,
    required String userId,
    required String transactionId,
    required String type,
    required int amount,
    Map<String, dynamic>? extraMetadata,
  }) {
    return logAction(
      enterpriseId: enterpriseId,
      userId: userId,
      module: 'orange_money',
      action: 'create_transaction',
      entityId: transactionId,
      entityType: 'transaction',
      metadata: {
        'type': type,
        'amount': amount,
        ...?extraMetadata,
      },
    );
  }

  /// Convenience method for logging sales.
  Future<String> logSale({
    required String enterpriseId,
    required String userId,
    required String saleId,
    required String module, // 'boutique' or 'gaz'
    required double totalAmount,
    Map<String, dynamic>? extraMetadata,
  }) {
    return logAction(
      enterpriseId: enterpriseId,
      userId: userId,
      module: module,
      action: 'create_sale',
      entityId: saleId,
      entityType: 'sale',
      metadata: {
        'totalAmount': totalAmount,
        ...?extraMetadata,
      },
    );
  }
}
